---
layout: default
title:  Apparmor fork and exec
parent: Developer Information
---


##  How Apparmor works for fork and exec process


**1\. Levels of execution ➞ ix \-**

profile myprof {  
    /my/executable ix,

}

above rule allows myprof to execute /my/executable with exactly the same permissions that myprof has. with ix child inherits permission same as parent 

So if you want to allow /my/executable to do something you just need to add that permission to myprof and it will be **i**nherited by /my/executable.

Executed binary will inherit the permissions from the current profile. Has the disadvantage when you merge permission scopes.

But if you want to give that particular permission **exclusively** to /my/executable and also to myprof you will need to use something else: 

* ux \- unconfined execute
* Ux \- unconfined execute – scrub the environment
* px \- discrete profile execute
* Px \- discrete profile execute – scrub the environment
* cx \- transition to subprofile on execute
* Cx \- transition to subprofile on execute – scrub the environment
* pix \- discrete profile execute with inherit fallback
* Pix \- discrete profile execute with inherit fallback – scrub the environment
* cix \- transition to subprofile on execute with inherit fallback
* Cix \- transition to subprofile on execute with inherit fallback – scrub the environment
* pux \- discrete profile execute with fallback to unconfined
* PUx \- discrete profile execute with fallback to unconfined – scrub the environment
* cux \- transition to subprofile on execute with fallback to unconfined
* CUx \- transition to subprofile on execute with fallback to unconfined – scrub the environment

The difference between a discrete profile and a subprofile is that a discrete profile is a *normal* profile, a subprofile is defined *inside* the current profile.

Profiles are inherited by subprocesses in the same mode as the parent (enforce/complain). So a process or thread created by a fork or a exec syscall will inherit the parent profile and it will have the same rule set as the parent.

**2\. Levels of execution ➞ px/Px**

Allow execution if binary has a profile

We can actually specify into which profile we should jump, sadly those explicit transitions are limited to 12 in a profile currently

profile binary /path/to/binary {  
    /path/to/otherbinary Px → usethisprofile,

}

**3\. Levels of execution ➞ cx/Cx**

Similar to Px/px transition. 

Target profile has to be a child profile of the current profile (either defined locally or via include)

**4\. Levels of execution ➞ ux/Ux**

Switch executed binary into an unconfined scope. Use with caution. Actually hardly ever.

4\. Px vs Cx and how to address target profiles


```
profile binary /path/to/binary {  
 /path/to/bin1 Cx -> somechild,  
  
 /path/to/bin2 Px -> specialprofile,  
 /path/to/bin3 Px -> binary//somechild,  
  
 /path/to/bin4 Cx -> specialprofile, # wrong.  
 profile somechild {}  
}  
  
profile specialprofile {}  
  

```
**5\. Levels of execution ➞ the combinations  of \[pPcC]\[iUu]x** 

Those combinations will try to jump to the profile as above but will fallback to ix/Ux if that fails. 

**6\. General notes for exec rules**  
Unless you really need to inherit the environment from the parent use the upper case version of the rule.

Forking always works. It does not need an exec rule.

  




 


Document generated by Confluence on Jul 15, 2024 13:04


[Atlassian](https://www.atlassian.com/)


 


